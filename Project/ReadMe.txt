1.1 Создать package – data. Работу продолжаем в нем.
Реализовать абстрактный класс User и его наследники Student и Teacher. 
Родитель имеет в себе общие данные (фио, год рождения, паспорт (серия номер)), 
а наследники собственные параметры (номер группы для Student, кафедра для Teacher).

1.2 Создать package – util. Работу продолжаем в нем
Создать классы WriterToTxt и ReaderFromTxt имеющие статичные методы для записи (write) /чтения (read) в/из txt файла.

1.3 Создать package – service. Работу продолжаем в нем
Создать интерфейс DataService описывающий реализацию конкретных сервисов по управлению сущностями (create, read)
Создать для сущности Student отдельный Service реализующий интерфейс DataService. 
Create и read операции реализуются путем вызова utils методов.

1.4 Создать package – view. Работу продолжаем в нем.
Создать абстрактный класс UserView, содержащий в себе метод void showTheBest(List<User> userList), 
внутри вызывающий абстрактный метод User findTheBest(List<User> userList).
Создать класс StudentView, унаследованный или имплементирующий UserView, содержащий в себе реализация findTheBest.

1.5 Создать package – controller. Работу продолжаем в нем.
Создать класс Controller содержащий в себе необходимые интерфейсы в виде переменных, 
а в конструкторе создаем объекты конкретных реализаций. 
Создаем метод createStudent(Student student) – реализующий логику, путем вызова соответствующих методов интерфейсов:
- Создания Студента.
- Записи в файл Студента.
- Чтения того, что мы записали.
- Возвращаем в методе то, что мы прочли в файле.


1.h Создать класс StudentGroup, содержащая в себе поля Teacher и список студентов.
Создать класс StudentGroupServiceImpl, в котором реализована логика чтения 
Студентов и Преподавателя из файла txt (реализация чтения файла опциональна), 
создания класса StudentGroup и возвращения его.
Создать метод в Controller createGroup(int groupNumber), 
в который передается номер группы, а возвращается StudentGroup.
Все вышеуказанное создать согласно принципам ООП пройдённым на семинаре.



2.1 Создать класс StudentGroupIterator, заставив его реализовать интерфейс Iterator<Student>.
Реализовать его абстрактные методы.
Реализовать метод remove().

2.2 Модифицировать класс StudentGroup, заставив его реализовать интерфейс Iterable<Student>.
Реализовать метод iterator() возвращающий экземпляр созданного нами итератора.
Модифицировать класс StudentGroupServiceImpl, добавив в него метод удаления студента по ФИО.
Модифицировать класс Controller, добавив в него метод удаления студента 
и вызывать в нем созданный метод из StudentGroupServiceImpl.

2.3 Модифицировать класс Student, заставив его реализовать интерфейс Comparable.
Реализовать контракт compareTo() со сравнением по году рождения студента.
Модифицировать класс StudentGroupServiceImpl, добавив в него метод сортировки списка студентов.
Модифицировать класс Controller, добавив в него метод сортировки списка студентов
и вызывать в нем созданный метод из StudentGroupServiceImpl.

2.4 Создать класс UserComparator, рефлизующий интерфейс Comparator<User>.
Реализовать контракт compareTo() со сравнением по ФИО.
Модифицировать класс StudentGroupServiceImpl, добавив в него метод сортировки 
студентов по ФИО.


2.h Создать класс GroupStream, содержащий в себе список StudentGroup 
и реализующий интерфейс Iterable<StudentGroup>.
Создать класс GroupStreamComparator<GroupStream>, реализующий сравнение количества групп,
входящих в GroupStream.
Создать класс GroupStreamServiceImpl, добавив в него метод сортировки списка потоков, 
используя созданный GroupStreamComparator.
Модифицировать класс Controller, добавив в него созданный сервис.
Модифицировать класс Controller, добавив в него метод, сортирующий список потоков, 
путем вызова созданного сервиса.



3.1 Создать пэкидж reporitory. Дальнейшие работы ведем в нем.
Реализовать в нем интерфейс Repository<E,I>.
Задать в созданном интерфейсе 2 абстрактных метода: E save(E entity), E find(I id).
Создать класс GroupRepository, имплементировав его от Repository.

3.2 Создать класс GroupRepository, имплементировав его от Repository<Group, Integer>.
В классе StudentGroupServiceImpl добавить новую переменную Repository<Group, Integer>.
В классе StudentGroupServiceImpl реализовать методы сохранения группы и поиска её по номеру.

3.3 Создать интерфейс UserRepository<U extends User,I>, унаследовав его от Repository<E, I>.
В интерфейс UserRepository<E,I> задать абстрактный метод E findByFio (String fio).
Создать класc StudentRepository, имплементировав интерфейс UserRepository.

3.4 Создать класc StudentRepository, имплементировав интерфейс UserRepository <Student, Integer>.
В классе StudentService добавить новую переменную StudentRepository.
В классе StudentService реализовать методы сохранения студента и его поиска по id и ФИО.


3.h Реализовать класc TeacherRepository (обобщение на ваше усмотрение).
Обобщить интерфейс DataService, чтобы он работал только с наследникам класса User.
Реализовать методы поиска и сохранения в классе TeacherService.
Реализовать как можно более обобщенный интерфейс Controller.
Создать классы StudentController, TeacherController, GroupController 
с методами сохранения и поиска соответствующих объектов.
* Реализовать такой же функционал для класса GroupStream.


4.1 Создать пекедж terminal. Дальнейшие работы ведем в нем.
Создать интерфейс CommandParser c методом String[] parseCommand (String inputCommand).
Создать класс TerminalReader, который содержит переменную CommandParser, и метод, 
который в бесконечном цикле слушает команды с помощью Scanner(System.in).

4.2 Сделать класс TerminalReader синглтоном.
Чтобы получить Singleton:
- приватные конструкторы,
- статическая переменная, которая содержат наш единственный экземпляр,
- фабричный метод, который при необходимости вызывает конструктор.

if (staticInstance == null){
staticInstance= new Instance();
}
return staticInstance;

4.3  Создать интерфейс CommandExecutable c абстрактным методом execute().
Реализовать 2 класса, имплементировав созданный интерфейс, 
CreateStudentExecutable и DeleteStudentExecutable. 
В унаследованных методах они должны обращаться к методам класса StudentService.
Подумать какие переменные могли бы содержать созданные классы.

4.4 Создать класc CommandExecutableFactory. 
Реализовать в нём метод CommandExecutable create (String[] input), 
где в зависимости от переданных параметров создается тот или иной класс. 
Использовать этот класс и метод в классе TerminalReader.

4.h Повторить задание с семинара №5.
Реализовать команды для терминального клиента: удалить студента по имени,
удалить студента по номеру группы и возрасту.
Продумать логику отображения результата выполнения команды.
Ссылка на тест для неприсутствующих на семинаре: 
https://docs.google.com/forms/d/1CEh-O3dhZ0km6bAtPPCFr9tM7PPz-w-hYqZD6DEtNiI/edit



5.1 Создать класс Command, который бы инкапсулировал в себе содержимое введенной команды.
Изменить сигнатуру у интерфейса ParseCommand, чтобы он вместо массива строк начал 
возвращать объект класса Command.
Реализовать в нем булевы методы для проверки введенных команд.
Oтредактировать класс CommandExecutableFactory, убрав из него хардкод и начав принимать на вход объект Command.

5.2 Создать класс LogingCommandExecutableFactory, наследующий класс CommandExecutableFactory.
Переопределить единственный метод так, чтобы он вызывал внутри себя метод предка, 
но в начале и конце распечатывал информацию о входных и выходных параметрах.

5.3  Переименовать класс CommandExecutableFactory в CommandExecutableFactoryImpl.
Создать интерфейс CommandExecutableFactory и имплементировать от него класс 
CommandExecutableFactoryImpl.
В классе TerminalReader реализовать DIP, то есть возможность менять реализации CommandExecutableFactory.

5.h Повторить задания с семинара 6.
Проверить и отредактировать весь проект на предмет соответствия SOLID.
Вместе с ссылкой указать, что вы поменяли и исходя из какого принципа.
* Продумать логику отображения результата выполнения команды.


6.1 Создать пекедж db.
Реализовать в нем абстрактный обобщенный класс Table, содержащий в себе переменную List<E> elements.
Реализовать в классе метод добавления элемента E save(E entity), который внутри себя добавляет entity 
в переменную elements.

6.2 Создать класс StudentTable.
Реализовать метод удаления по имени boolean removeByName (String name),
который бы удалял студента из таблицы по имени.
Создать в классе StudentRepository зависимость класса StudentTable.
Вызывать метод removeByName из одноименного метода класса.

6.3 Создать реализацию CommandParser. Чтобы разбить строку используйте метод split().
Запустить приложение, вызвав метод класса TerminalReader, не забыв создать экземпляры зависимостей.


6.h Повторить задания 1,2 с семинара 7.
Выполнить задание 3 с семинара 7.
Реализовать метод save класса StudentRepository так, чтобы он в своем теле вызывал 
метод create класса StudentTable.
Критерии оценки: приложение запускается, можно с терминала создать студента и удалить студента по имени.


